## 웹서버 & 웹앱서버(WAS) 

### 웹서버(WS) VS 웹앱서버(WAS) 차이 

- 차이점 설명 (웹서버와 WAS)
  - 웹서버 WS : 정적 리소스(파일)만을 전달해줌
  - 웹앱서버 WAS : 애플리케이션 로적을 전달해줌
- 두 용어 사이의 경계도 모호하지만, JAVA기준 서블릿 컨테이너의 기능을 제공하면 WAS라고 칭하며, 애플리케이션 코드를 실행하는데 특화되어있음


## 웹페이지가 꾸며지는 두가지 방식의 차이
- 두가지 : 서버사이드 랜더링 vs 클라이언트랜더링


### CSR : 클라이언트 사이드 랜더링
- HTML에는 텅텅비고 모양만 만들어진 사이트가 내려가고, 클라이언트 컴퓨터에서 자바스크립트가 돌면서 값이 채워지는 
- 주로 React, Vue 등이 사용된다


### SSR : JSP, 타임리프, 머스태취
- 대부분 과거의 기술인데, 서버에서 완성된 형태의 페이지를 보여주는 방식
- 무조건 나쁜건 아니고 장단이 있어서 요즘엔 SSR+CSR같이씀
- 백엔드개발자라면 SSR은 배워야하고, CSR은 선택

## 앞으로의 수업진행
- 웹백엔드 기술의 역사가 흘러간대로 따라가봄
  - 먼저 Servlet
  - MVC도입
  - 프레임워크와 스프프링부트의 시대
- 백엔드 앞으로 Reactive/WebFlux 는 안배움(비동기 자바스프링)

<br><br><br>

## 웹 시스템의 구성

### 웹시스템 최소구성

![](https://user-images.githubusercontent.com/31065684/137045239-ad1899f0-1085-4e24-8711-6cbc26c0f50c.png)

- 웹 서비스 제공을 위한 최소구성 : WAS, DB
- 단점 : was가 너무 많은 기능을 가지고 있어서 서버 과부하 우려
  - 애플리케이션 로직은 비싸다 : 복잡한 로직, 비지니스로직이 있다
  - 정적 리소스 파일 제공은 싸다 : 그냥 파일만 전달해주면 된다
  - WAS는 생각보다 잘 죽는다.  Was 가 죽으면 오류화면조차도 띄워주는게 불가능하다

- 왜 약간 라즈베리파이 같은걸로 Apache+PHP+MySQL=APM 깔아서 뭐 만드는게 다 이런느낌 정적웹서비스를 최소한으로 구성한다음에, 인터넷망으로 FTP서버를 누구나 손쉽게 구현할 수 있다!



### 개선구조 WS/WAS 분리(정적웹 제공과 어플리케이선 서버 분리)

![](https://user-images.githubusercontent.com/31065684/137045255-d812f651-30ec-4392-9f7d-f9d2fc260d4d.png)

- 정적 리소스는 기존대로 WS에서 처리
- 동적인 처리는 WAS로 위임하고, was는 오직 중요한 애플리케이션 로직처리만을 담당





### WS/WAS 분리해서 얻을수 있는 장점 1 : 상황과 특수성에 맞게 효율적으로 리소스를 관리할 수 있다

- 효율적으로 컴퓨팅 파워(리소스)를 관리 할 수 있다
  - 정적인 요청이 많다면 WS만 늘릴수 있고
  - 동적인 요청이 많다면 WAS만 증설하면 되니까 
- ![](https://user-images.githubusercontent.com/31065684/137045273-8ea3434b-a27a-41fe-85ac-7c4a2ef1f563.png)



### WS/WAS 분리해서 얻을수 있는 장점 2 : 장애시 파급이 작다

- 사고시 파급효과가 작다 - 장애시 오류화면이라도 제공할수 있고, 최소한의 동작이 가능)

- 서버애러(장애)의 범위를 한정(고립)시킬 수 있다
  - WS : 정적 리소스만 제공하는 웹서버는 잘 죽지 않음
  - WAS : 애플리케이션 로직은 개발자가 개발하는 부분이라 죽을 가능성이 높다.

- ![](https://user-images.githubusercontent.com/31065684/137045292-d167e817-a144-44df-8037-489c53a3f9d4.png)







## 서블릿
- http 문자열 파싱한 객체인데
- 자바 웹개발자가 문자열 파싱을 매번할수가 없으니까 표준에 맞춰서 쓰기 쉽게 만들어준 자바 객체
- 실습따라하면 이해됨





### 톰캣WAS가 HTTP 요청에 응답하기까지 (request to response)

• HTTP 요청시 • WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출 • 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용 • 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력 • WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성 



### 서블릿 컨테이너는 싱글톤이다

고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율 • 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용 • 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근 **•** **공유 변수 사용 주의** : 싱글톤은 공유변수 사용주의!! : 스프링 핵심원리

- 서블릿 컨테이너 종료시 함께 종료 

JSP도 서블릿으로 변환 되어서 사용 • 동시 요청을 위한 멀티 쓰레드 처리 지원 : 개발자가 멀티쓰레드를 크게 신경쓰지 않아도 WAS가 해결해줌



<br><br><br>



## 멀티쓰레드(동시요청)

- 사실 서블릿을 호출하는건 쓰레등!
- 쓰레드란? : 애플리케이션 코드를 하나하나 순차적으로 실행하는것은 쓰레드

### 요청마다 쓰레드 생성 방식

- 장점

  - 동시ㅛ청
  - 리소스 허용될떄까지 처리

- 단점

  - 쓰레드 생성 비용은 비싸다(CPU의 시간과 메모리를 잡아먹는다)

    - 더해서 매 요청마다 쓰레드 생성/파괴 하는 작업을 반복한다

  - 쓰레드 생성에 제한이 없어 임계점을 초과할수 있다

  - ㅅ

    

### 쓰레드 풀 생성방식

- 특징
  - **`요청마다 쓰레드`를 생성하는 방식의 단점을 보완**
  - 생성가능한 최대 쓰레드 갯수 관리 : 톰캣기준 최대 200개,변경가능
  - 쓰레드를 미리 생성해 놓는 방식 : 필요할때 생성하지 않고, 이미 생성되어 있는 쓰레드를 `쓰레드풀`에서 꺼내 사용
  - 쓰레드 반납Only : 쓰레드를 종료해서 OS에 자원을 반납하지 않음. 쓰레드풀에 반납하는 개념
  - 스키장 갈때 매 겨울마다 보드복,스키장비를 구매하지않고, 한철 빌려서 쓰고 반납하는 방식
- 장점
  - 응답시간이 빠름 : 쓰레드를 생성하는 시간과 CPU자원을 아낄 수 있다
  - 서버다운의 위험 감소 : 많은 요청이 동시에 들어올때 너무많은 쓰레드를 생성해 서버가 다운되는 위험을 막을수 있다. 서버가 수용 가능한 정도까지의 기존 요청은 계속 처리하면서, 오바되는 요청은 거절을 떄려서 살수있는놈은 살릴수 있다
- 단점
  - 단점을 따로 언급하지 않을정도로 좋다 그냥 이게 주인공이고 정답이다
  - 컨텍스트 스위칭은 쓰레드풀 생성방식에도 존재하는데..??(질문올리기)
  - 다른방식으로의 접근은 비동기방식 처리? Nodejs, RxJava/Reactive



## 쓰레드풀의 실무 팁

### 최대 쓰레드 수

-  WAS의 주요 튜닝 포인트는 최대쓰레드 수(Max Thread)
  - Max Thread 너무 높으면(많으면)
    - 동시 요청이 많으면 서버 임계점 초과로 서버가 다운된다
    - 클라우드라면 Max Thread수를 줄이지말고, 가용파워를 늘려 트레픽을 처리하고, 이후에 튜닝을 하면 된다
  - Max Thread 너무 낮으면(적으면)
    - 동시요청이 많아지면(트래픽 증가시) 서버 리소스는 여유로운데, 클라이언트는 응답지연된다
    - 성능은 성능대로 안나오고, 클라이언트는 클라이언트대로 지연되고 밀리는 컴퓨팅리소스 낭비

### 쓰레드 풀의 적정숫자

- 적정 숫자는 어떻게 찾는지는 상황에 따라 다름

  -  CPU, 메모리, 디비조회랑

- 성능테스트를 꼭 해서 튜닝을 해보자 : 실제 서비스와 유사하게 성능테스트 시도

  - 아파치ab, 제이미터, nGrinder

    

### 개발자는 멀티쓰레드를 신경쓸 필요가 없다

- 멀티쓰레드는 WAS 가 책임지고 지원해주므로 개발자는 멀티쓰레드 관련한 코드를 신경쓸 필요가 없다
- 개발자는 마치 싱글쓰레드 프로그래밍을 하듯 편리하게 소스코드를 개발하면 된다!(나머지는 WAS가 처리해주니까)
- 단! 멀티쓰레드가 추상화되어있으므로 싱글톤 객체(서블릿, 스프링빈) 사용시 공유변수에 의한 에러가 발생하지 않도록 인지하자




<br><br><br>



## 실습포인트

### Servlet관련
- @ServletComponentScan : 서블릿을 찾아서 자동으로 등록하는 어노테이션
- 서블릿은 HTTP 프로토콜을 개발자가 직접 파싱하기 어려우니까 한단계 쓰기 쉽게 파싱/추상화 해준 계층임
- HTTP 프로토콜 소켓통신으로 받아서 파싱해서 만들수 있음(WAS프로젝트)


### 인텔리제이 단축키
- soutv, soutm

### HTTP 요청 데이터 3가지 방식
- 쿼리스트링 (GET파라미터에서) : 검색, 필터, 페이징
- HTML FORM (POST파라미터에서) : 메시지 바디에 쿼리파라미터 형식으로 전달
- messageBody (POST/PUT/PATCH): 주로 JSON형식을 많이 사용

### 복수의 파라미터를 쿼리스트링  


### HTTP 메시지 바디의 데이터 형식을 지정하는 http헤더필드 content-type
- content-type은 HTTP 메시지 바디의 데이터 형식을 지정한다.
- GET URL 쿼리 파라미터 형식에서는 HTTP 메시지 바디가 없기때문에  content-type이 없다.
- POST HTML Form 형식: application/x-www-form-urlencoded 필수

