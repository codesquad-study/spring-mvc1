







### 서블릿

- 동적으로 원하는 HTML 생성 가능

- BUT! 뷰 코드를 넣게되면 서블릿 코드가 복잡해진다
  - 템플릿 엔진 등장! HTML에서 **필요한 곳만 동적으로 변경 가능**



### 템플릿 엔진의 한계

- 서블릿과 JSP를 통해 필요한 곳에서 동적으로 변경 가능해졌다
- Java 코드, repository 코드 등 다양한 목적을 가진 코드들이 모두 jsp 내부에 있음
  - 유지보수 노노..우..



### MVC 패턴 

#### 도입 배경

비즈니스 로직과 뷰 코드를 분리

- 비즈니스 로직 -> 서블릿
- JSP -> 뷰



#### **Model View Controller**

**컨트롤러** 

- HTTP 요청 처리 담당
- 요청 파라미터 검증
- 비즈니스 로직 실행
  - 컨트롤러와 분리하여, 비즈니스 로직은 서비스(Service)라는 계층을 별도로 만들어서 처리
- 데이터 조회 후 모델에 담아 응답



**모델**

- 뷰에 출력할 데이터 담는다
  - 비즈니스 로직과 데이터 접근 관련 코드 몰라
  - 그저 뷰에 담을 데이터만 잘 가져오고 잘 담으면 된다

**뷰**

- 화면 렌더링
- HTML 생성 부분



#### 한계

**중복 코드**

- **포워드 중복**
  - View로 이동하는 코드(RequestDispatcher)가 항상 중복 호출

- **ViewPath** 중복

  - 여러 서블릿들이 prefix와 suffix를 공유한다

  - ```
    String viewPath = "/WEB-INF/views/new-form.jsp";
    ```

    - prefix: /WEB-INF/views/
    - suffix: .jsp

- 메서드로 묶더라도?

  - 실수로 호출하지 않으면? 노답..ㅠ
  - 개발자의 재량에 맡기지 말자

**공통 처리가 어렵다는 문제**

-  **프론트 컨트롤러**(Front Controller) **패턴**으로 해결!

  - 모든 요청을 가장 먼저 처리하여 서블릿으로 전달

  

### **FrontController** 패턴

#### 특징

- 프론트 컨트롤러 서블릿 하나로 모든 클라이언트의 요청 처리
  - 공통 처리 가능
  - 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

- 프론트 컨트롤러가 해당 요청과 매핑되는 컨트롤러를 찾아 호출
- 스프링 웹 MVC의 **DispatcherServlet**도 이 패턴 적용



#### 요청 처리 과정

- 1. request를 통해 url 획득

- 2. 해당 url과 매핑된 컨트롤러 찾기

- 3. 컨트롤러의 service() 메소드 호출
     - ModelView (모델)반환

- 4. viewResolver에서 뷰를 반환

     - 뷰 이름에 해당하는 객체를 찾거나 혹은 새로 생성하여 리턴

     

### **redirect vs forward**

- 리다이렉트
  - 실제 클라이언트(웹 브라우저)에 응답이 나갔다가, **클라이언트가 redirect 경로로 다시 요청**
  - 클라이언트가 인지할 수 있고, **URL 경로도 실제로 변경**
- 포워드
  - **서버 내부에서 일어나는 호출**이기 때문에 클라이언트가 전혀 인지하지 못한다